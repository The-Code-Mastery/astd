
```{r, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

# Spatial Point Patterns

Recommended reading: 

* chapter 7 in _Applied Spatial Data Analysis with R, second edition_ ; Springer (2013).
* [Statistical Analysis and Modelling of Spatial Point Patterns](http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0470014911.html) Dr. Janine Illian, Prof. Antti Penttinen, Dr. Helga Stoyan, Dietrich Stoyan
* Spatial Point Patterns: methodology and applications with R. Badelley, Rubak, Turner. (The spatstat book) http://spatstat.org/

Spatial Point Pattern analysis is concerned with 

* describing the distribution of points (a _pattern_) in space; 
* makeing inference about the _process_ that (could have) generated this pattern

Usually a 2-D Euclidian (metric) space is assumed:

```{r}
library(sf)
demo(nc, ask = FALSE, echo = FALSE) # load nc
pts = st_centroid(nc)
library(maptools) # contains the Spatial -> spatstat routines
library(spatstat)
as.ppp(as(pts, "Spatial"))
```

Over a give window $W$, we observe a number of $n$ events (points)  $S_i$, $i=1,...n$.

We distinguish:

* a point _pattern_: the observed locations of events in their window
* a point _process_: the stochastic process that generates point pattern as its outcome

We can describe:

* first order properties: concerning the **density** of the events (is the density of the point pattern constant over the window?)
* second order properties: concerning the **interaction** between events (do events attract each other, repulse each other, or act indifferently with respect to each other?)

The baseline process is _completely spatial random_ (CSR): 

* the density of the process is constant, and 
* points occur completely independently, meaning there is no interaction.

Testing for constant density can be done with the quadrat counts test:

* our point pattern has $N$ events
* cut the area in $n$ boxes of equal size
* under CSR, the _expected_ number of points per box is then $N/n$
* count the number of events per box, $q_i$
* under the null hypothesis of CSR, $\sum_{i=1}^{n}(q_i - N/n)^2$ now follows a $\chi^2$ distribution with $n-1$ degrees of freedom 

In case you are unfamiliar with what $\chi^2$ is, an approximate permutation test involves

* generate a large ($>1000$) number of independent CSR patterns of size $N$ over the target region (`spatstat::runifpoint`)
* compute $\sum_{i=1}{n}(q_i - N/n)^2$ for each of them, and take the 95-percentile of them
* compare the test statistic with it; is it larger, then we reject the CSR hypothesis with 95% confidence

Other tests involve e.g. distances between points.

Caveats:

* how to determine $n$?
* can we get equally sized boxes in real cases?
* as usual: not significant does not mean that the process _is_ CSR, it can also indicate lack of power (small sample)

Alternatives to CSR: 

* attracting or repulsing processes, constant density (e.g. Strauss)
* no interaction process, varying density (log Gaussian Cox process)

Software:

* spatial: [spatstat](https://spatstat.github.io/) (JSS papers :[1](http://www.jstatsoft.org/v12/i06/), [2](http://www.jstatsoft.org/v55/i11/))
* spatio-temporal: CRAN: [stpp](https://cran.r-project.org/package=stpp) [JSS paper](https://www.jstatsoft.org/article/view/v053i02); [lgcp](https://cran.r-project.org/web/packages/lgcp/) JSS papers: [1](http://www.jstatsoft.org/v52/i04/), [2](http://www.jstatsoft.org/v63/i07/)

Typical spatio-temporal questions involve whether the density (if varying) varies over time in a way that is independent from the variation over space. In case of an epidemics, movement of the epidemic would imply interaction (FMD examples in the stpp package/paper).

Functions:

* K-function (Ripley's K): the average number of other points found within the distance $r$ from the typical point.
* L-function: similar to K, but CSR is a line rather than a parabolic curve
* g-function: (pair-correlation function); recommended by Illian et al., similar to L and K but $g(r) = 1$  for CSR cases

Inference:

* inference often follows a simulation approach: point patterns are simulated given a particular process, and the correspondence of the (set of) simulations to the observed processed is considered.

```{r}
library(spatstat)
data(japanesepines)
summary(japanesepines)

library(maptools)
spjpines <- as(japanesepines, "SpatialPoints")
summary(spjpines)

spjpines1 <- elide(spjpines, scale=TRUE, unitsq=TRUE)
summary(spjpines1)

pppjap <- as(spjpines1, "ppp")
summary(pppjap)

data(redwoodfull)
spred <- as(redwoodfull, "SpatialPoints")
data(cells)
spcells <- as(cells, "SpatialPoints")
dpp<-data.frame(rbind(coordinates(spjpines1), coordinates(spred), 
   coordinates(spcells)))
njap<-nrow(coordinates(spjpines1))
nred<-nrow(coordinates(spred))
ncells<-nrow(coordinates(spcells))
dpp<-cbind(dpp,c(rep("JAPANESE",njap), rep("REDWOOD", nred), rep("CELLS", ncells))) 
names(dpp)<-c("x", "y", "DATASET")


library(lattice)
print(xyplot(y~x|DATASET, data=dpp, pch=19, aspect=1))

envjap <- envelope(as(spjpines1, "ppp"), fun=Gest, r=r, nrank=2, nsim=99)
envred <- envelope(as(spred, "ppp"), fun=Gest, r=r, nrank=2, nsim=99)
envcells <- envelope(as(spcells, "ppp"), fun=Gest, r=r, nrank=2, nsim=99)
Gresults <- rbind(envjap, envred, envcells) 
Gresults <- cbind(Gresults, 
y=rep(c("JAPANESE", "REDWOOD", "CELLS"), each=length(r)))
## # CHANGED DATASET TO y RSB
## #	save(Gresults, envjap, envred, envcells, file="sppaGestEnv.RData")


###################################################
### code chunk number 21: sppa.Rnw:562-563
###################################################
#load("Gresults.RData")

print(xyplot(obs~theo|y , data=Gresults, type="l", 
xlab = "theoretical", ylab = "observed", # EJP
panel=function(x, y, subscripts) {
   lpolygon(c(x, rev(x)), 
   c(Gresults$lo[subscripts], rev(Gresults$hi[subscripts])),
   border="gray", col="gray"
)
llines(x, y, col="black", lwd=2)
}))

```

## density:

```{r}
plot(density(as.ppp(spred)), axes=TRUE)
points(as.ppp(spred), col="green2", pch=19)
```

## K-functions, homogeneous, inhomogeneous

```{r}
opar <- par(mfrow=c(1,2))
plot(envelope(as.ppp(spred), Kest, verbose=FALSE), main="Homogeneous")
plot(envelope(as.ppp(spred), Kinhom, verbose=FALSE), main="Inhomogeneous")
```

```{r}
plot(density(as.ppp(spred)), axes=TRUE)
points(as.ppp(spred), col="green2", pch=19)
plot(density(as.ppp(spred), adjust = 0.5), axes=TRUE,  main = "0.5 x the default bandwidth")
points(as.ppp(spred), col="green2", pch=19)
```

```{r}
opar <- par(mfrow=c(1,2))
plot(envelope(as.ppp(spred), Kest, verbose=FALSE), main="Homogeneous")
plot(envelope(as.ppp(spred), Kinhom, adjust = 0.5, verbose=FALSE), main="Inhomogeneous")
```
